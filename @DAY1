(1)
You have been given an array ‘a’ of ‘n’ unique non-negative integers.Find the second largest and second smallest element from the array.
Return the two elements (second largest and second smallest) as another array of size 2.
Example :
Input: ‘n’ = 5, ‘a’ = [1, 2, 3, 4, 5]
Output: [4, 2]
The second largest element after 5 is 4, and the second smallest element after 1 is 2.

import java.util.Arrays;
class Solution
{
        public static int[] get_second(int n, int[]a)
        {
                Arrays.sort(a);
                return new int[]{a[n-2],a[1]};
        }
}


(2)
import java.util.*;
class largest_element
{
	public static int largest_element(int arr[],int n)
	{
		int max=arr[0];
		for(int i=1;i<n;i++)
		{
			if(arr[i]>max)
			{
				max=arr[i];
			}
		}
		return max;
	}
}


(3)
You have been given an array ‘a’ of ‘n’ non-negative integers.You have to check whether the given array is sorted in the non-decreasing order or not.
Your task is to return 1 if the given array is sorted. Else, return 0.
Example :        Input: ‘n’ = 5, ‘a’ = [1, 2, 3, 4, 5]        Output: 1
The given array is sorted in non-decreasing order; hence the answer will be 1.

class solution
{
        public static int isSorted(int n,int[]a)
        {
                for(int i=0;i<n-1;i++)
                {
                        if(a[i]>a[i+1])
                        {
                                return 0;
                        }
                }
                return 1;
        }
}


(4)
Check if Array Is Sorted and Rotated Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.
There may be duplicates in the original array.
Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.

Example 1:
Input: nums = [3,4,5,1,2]
Output: true
Explanation: [1,2,3,4,5] is the original sorted array.
You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].

Example 2:
Input: nums = [2,1,3,4]
Output: false
Explanation: There is no sorted array once rotated that can make nums.

Example 3:
Input: nums = [1,2,3]
Output: true
Explanation: [1,2,3] is the original sorted array.
You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.

class solution
{
        public boolean check(int[]nums)
        {
                int count=0;
                for(int i=0;i<nums.length;i++)
                {
                        if(nums[i]>nums[(i+1)%nums.length)
                        {
                                count++;
                        }
                        if(count>1)
                        {
                                return false;
                        }
                }
                return true;
        }
}


